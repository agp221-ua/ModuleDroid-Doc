{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>aqui iria una explicacion de que es y que quiere hacer</p>"},{"location":"about/","title":"About","text":""},{"location":"configurator/","title":"Configurator","text":""},{"location":"navigator/","title":"Navigator","text":""},{"location":"kernel/kernel/","title":"ModuleDroid Kernel","text":""},{"location":"kernel/kernel/#introduction","title":"Introduction","text":"Info <p>The ModuleDroid kernel documentation is intended for those who wish to develop modules or plugins for the framework or want to learn more about its inner workings. It is not necessary to understand the internal operation of the kernel to use the framework.</p> <p>ModuleDroid is based on a system of modules or plugins, where each one is independent of the rest and can be added or removed from the system at any time. The system consists of a core (kernel) that manages the modules and plugins running in the system, as well as the events that occur within it.</p> <p>Internally, the kernel is composed of a set of components responsible for managing different aspects of the system. If a module needs to interact with any system functionality, it does so through the kernel, which then handles the interaction with the corresponding component.</p> <p></p> <pre><code>flowchart TB\n    subgraph k[KERNEL]\n        direction TB\n        f(Facade)\n        subgraph c[INTERNAL BUS]\n            c1(Internal Bus)\n        end\n        subgraph sc[SUBCOMPONENTS]\n            sc1(Activity Lifecycle)\n            sc2(Intent manager)\n            sc3(Kernel Configurator)\n            sc4(Preferences Manager)\n        end\n    end\n\n    subgraph p[Plugins]\n        direction LR\n        pa(Plugin 1) \n        pb(Plugin 2)\n        pc(Plugin N)\n    end\n    p --&gt; f\n\n    f &lt;-.-&gt; sc\n    c &lt;-.-&gt; sc\n    sc ---&gt; System\n</code></pre>"},{"location":"kernel/kernel/#plugins","title":"Plugins","text":"<p>Plugins are modules that operate independently of the kernel, meaning they can be added or removed from the application at any time without affecting other modules.</p> Note <p>It is possible to create plugins that rely on other plugins as dependencies; however, this practice should be minimized to maintain the independence of each plugin as much as possible.</p> <p>Plugins communicate with the kernel via the Facade component, allowing the plugin to remain abstracted from the kernel's internal implementation and only interact with the core through a defined interface.</p>"},{"location":"kernel/kernel/#kernel","title":"Kernel","text":"<p>The kernel is the core of the framework, responsible for managing the modules or plugins running in the system and handling the events that occur within it. Internally, the kernel consists of a set of components that manage various aspects of the system. If a module needs to interact with any system functionality, it communicates with the kernel, which then handles the interaction with the appropriate component.</p> Warning <p>The kernel utilizes a customized <code>Application</code> class. If, for any reason, there is a need to implement a custom Application, it is important to consider that the kernel may not function correctly. To minimize potential incompatibilities, it is recommended to extend from <code>ModuleDroidApplication</code> in the <code>Kernel Configurator</code> subcomponent and to call the <code>super</code> method within the <code>onCreate</code> method.</p> Warning <p>The kernel runs on the main thread of the application, so blocking code should not be executed within it.</p> Warning <p>Accessing any aspect of the system by bypassing the kernel may result in unexpected behavior. It is recommended to avoid this practice. If access to a system functionality not implemented in the kernel is required, please notify the development team to consider adding it to the kernel or provide an alternative solution.</p>"},{"location":"kernel/kernel/#components","title":"Components","text":"<p>As previously mentioned, the kernel is composed of a set of components responsible for managing and facilitating access to different aspects of the system.</p> <p>Below are the components that make up the kernel:</p> <p>Facade</p><p>Manages calls to subcomponents from plugins</p> <p>Internal Bus</p><p>Manages communication between kernel subcomponents</p> <p>Activity Lifecycle</p><p>Manages events subscribed to the activity lifecycle</p> <p>Intent Manager</p><p>Manages events related to intents</p> <p>Kernel Configurator</p><p>Manages events related to kernel configuration</p> <p>Preferences Manager</p><p>Manages events related to preferences</p>"},{"location":"kernel/components/facade_kernel/","title":"Facade","text":"<p>The Kernel Facade is the component responsible for managing the communication between modules and the kernel, as well as handling the kernel's responses to the modules. Essentially, it acts as an intermediary between the modules and the kernel, ensuring that communication is smooth and as simple as possible for both the modules and the end user.</p>"},{"location":"kernel/components/facade_kernel/#functionality","title":"Functionality","text":"<p>The operation of the Kernel Facade is straightforward. It handles the communication between modules and kernel components, and vice versa, so that the modules do not need to worry about how they interact with the kernel. To achieve this, the Kernel Facade exposes a set of methods that the modules can use to communicate with the internal components. The primary function of the Kernel Facade is to abstract the complexity of kernel communication from the modules, allowing them to avoid needing to understand or depend on the internal workings of the framework.</p>"},{"location":"kernel/components/facade_kernel/#structure","title":"Structure","text":"<p>Info</p> <p>The Kernel Facade is composed of a set of subfacades, each responsible for managing communication with specific internal kernel components. This subdivision exists because the Kernel Facade is a highly complex component, and splitting it into subfacades helps improve its comprehensibility and maintainability.</p> <pre><code>    flowchart TB\n        subgraph p[\" \"]\n            direction LR\n            pa(Plugin 1) \n            pb(Plugin 2)\n            pc(Plugin N)\n        end\n\n        subgraph f[\" \"]\n            f1(Facade)\n            subgraph sf[\"  \"]\n                sf1(Subfacade 1)\n                sf2(Subfacade 2)\n                sf3(Subfacade N)\n            end\n        end\n        subgraph sc[\" \"]\n            direction TB\n            sc1(Subcomponent 1)\n            sc2(Subcomponent 2)\n            sc3(Subcomponent N)\n        end\n\n        p --&gt; f\n        f1 --&gt; sf1\n        f1 --&gt; sf2\n        f1 --&gt; sf3\n        sf1 --&gt; sc1\n        sf2 --&gt; sc2\n        sf3 --&gt; sc3\n</code></pre>"},{"location":"kernel/components/internal_bus/","title":"Internal Bus","text":""},{"location":"kernel/components/internal_bus/#introduction","title":"Introduction","text":"<p>The <code>Internal Bus</code> is one of the core components that, unlike subcomponents, does not focus on obtaining or processing results. Instead, it is responsible for managing data that is global to the framework and, therefore, cannot be privatized within a specific component. This functionality is useful for actions that require data not belonging to a particular subcomponent but are necessary to perform a given task. To avoid inserting unnecessary dependencies into subcomponents, the <code>Internal Bus</code> was created as an internal bus for global data.</p> <p>For example, the subcomponent responsible for providing the current <code>Activity</code> should not know the system used to obtain it, nor should it be aware of who is responsible for it. This is where the <code>Internal Bus</code> comes into play, as it provides these data to the subcomponents that need them, abstracting them from the complexity of obtaining the data.</p> Note <p><code>Internal Bus</code> does not know the kernel subcomponents; it only focuses on connecting data between them.</p>"},{"location":"kernel/components/internal_bus/#structure","title":"Structure","text":"<pre><code>    flowchart TB\n        subgraph k[KERNEL]\n            direction TB\n            subgraph c[\" \"]\n                c1(Subcomponent 1)\n                c2(Subcomponent 2)\n                c3(Subcomponent N)\n            end\n            direction TB\n            ib(Internal Bus)\n        end\n        c --&gt; System\n        c1 &lt;-.-&gt; ib\n        c2 &lt;-.-&gt; ib\n        c3 &lt;-.-&gt; ib\n</code></pre> <p>To maximize the independence of the <code>Internal Bus</code> from subcomponents, an enum called <code>Keys</code> is used. This enum contains the keys for the data that can be obtained from other subcomponents. This way, subcomponents do not need to know the structure of the Internal Bus, they only need to know the key for the data they require, and the <code>Internal Bus</code> takes care of actively retrieving it. For this, <code>Internal Bus</code> expects subcomponents that can provide the data to subscribe to each <code>key</code> during the kernel configuration process.</p>"},{"location":"kernel/components/internal_bus/#data-subscription","title":"Data Subscription","text":"<p>As previously mentioned, the Internal Bus does not know the kernel subcomponents, so it uses a subscription system to allow subcomponents to offer their data to the <code>Internal Bus</code>. For this, the <code>Internal Bus</code> exposes a method, <code>subscribe</code>, which takes as parameters the key of the data to be subscribed and a callback that will be executed when the data is requested.</p>"},{"location":"kernel/components/internal_bus/#data-retrieval","title":"Data Retrieval","text":"<p>To retrieve data, the Internal Bus exposes a method, <code>get</code>, which takes as a parameter the key of the data to be obtained. This method searches the subscription map to check if any subcomponent provides the requested data. If it exists, the associated callback is executed, the data is retrieved, and returned. If no subscription is associated with the key, an exception is thrown.</p>"},{"location":"kernel/components/subcomponents/activity_lifecycle/","title":"Activity Lifecycle","text":"<p>The <code>Activity Lifecycle</code> subcomponent is a part of the kernel responsible for intercepting the lifecycle events of the application's activities to execute corresponding actions. Its purpose is to allow other subcomponents and application plugins to react to these activity lifecycle events to perform various actions.</p> Example <p>For instance, consider a plugin that manages navigation between screens in the application. This plugin needs to know when a new activity is created to pass relevant data to the new screen. To achieve this, it could subscribe to the <code>onCreate</code> event in the activity lifecycle and execute the necessary actions when this event occurs.</p> Info <p>Currently, the <code>Activity Lifecycle</code> subcomponent does not officially support intercepting fragment lifecycle events.</p>"},{"location":"kernel/components/subcomponents/activity_lifecycle/#retrieving-activities","title":"Retrieving Activities","text":"Warning <p>The reference to these Activities can change at any time, so it is recommended not to store the reference but to call the method when needed. Another option is to create a computed property where the getter calls the desired method.</p> <p>To retrieve Activities, the Facade provides different options depending on the situation:</p> Method Description Current Activity Returns the activity that is currently resumed. Resuming Activity Returns the activity that is currently resuming. Starting Activity Returns the activity that is currently starting. Creating Activity Returns the activity that is currently being created. Preferred Activity Returns the activity in the order <code>resuming</code> &gt; <code>starting</code> &gt; <code>creating</code> &gt; <code>current</code>. This is offered as a simplified solution to access the activity during uncertain times when the state is unknown. <p>Alternatively, there are two methods to retrieve the desired activity: one that returns a nullable value (Activity?) and another that returns a non-nullable value (Activity), which will throw an <code>IllegalStateException</code> if the desired activity is not found.</p> Example <p>For example, let's assume we want to obtain the current activity of the application from a code where direct access to the activity is not available.</p> <pre><code>// Optional way\nval currentActivity = Facade.getCurrentActivity() ?: // Handle case where no activity is found\n\n// Exception way\ntry {\n    val currentActivity = Facade.getCurrentActivityOrFail()\n} catch (e: IllegalStateException) {\n    // Handle case where no activity is found\n}\n\n// Property way\nval currentActivity: Activity?\n    get() {\n        return Facade.getCurrentActivity()\n    }\n//...\nthis.currentActivity // Access the current activity\n</code></pre>"},{"location":"kernel/components/subcomponents/activity_lifecycle/#event-subscription","title":"Event Subscription","text":"<p>As mentioned earlier, the <code>Activity Lifecycle</code> subcomponent uses a subscription system for activity lifecycle events. The <code>Activity Lifecycle</code> provides a set of methods that allow subscribing to these events.</p> <p>To achieve this, the <code>Activity Lifecycle</code> subcomponent intercepts lifecycle events. When an activity lifecycle event occurs, before the corresponding activity method is executed, all subscriptions to that event that meet the relevant conditions are executed.</p> <p>The available events for subscription are: <code>onPreCreate</code>, <code>onCreate</code>, <code>onPostCreate</code>, <code>onPreStart</code>, <code>onStart</code>, <code>onPostStart</code>, <code>onPreResume</code>, <code>onResume</code>, <code>onPostResume</code>, <code>onPrePause</code>, <code>onPause</code>, <code>onPostPause</code>, <code>onPreStop</code>, <code>onStop</code>, <code>onPostStop</code>, <code>onPreDestroy</code>, <code>onDestroy</code>, <code>onPostDestroy</code>, <code>onRestart</code>, <code>onSaveInstanceState</code>.</p> <p>Additionally, all of these events offer different subscription method versions, adapting to the specific case as needed based on certain conditions:</p> Method call parameters Description <code>subscription</code> This call simply adds the subscription, which will be executed when the event is captured. <code>id</code><code>subscription</code> This call only executes the subscription when the id of the current activity matches <code>id</code>. <code>activityClass</code><code>subscription</code> This call only executes the subscription when the class of the current activity matches <code>activityClass</code>. <code>id</code><code>activityClass</code><code>subscription</code> This call only executes the subscription when both the id and class of the current activity match <code>id</code> and <code>activityClass</code>, respectively. Example <p>Suppose we want to subscribe to the <code>onCreate</code> event of a specific activity. We could use the following call:</p> <pre><code>Facade.addOnCreateSubscription { activity, bundle -&gt;\n    // Execute actions when MyActivity is created\n}\n</code></pre> <p>Now, imagine we want to subscribe to the <code>onStart</code> event of the activity with id <code>myActivityId</code>:</p> <pre><code>Facade.addOnStartSubscription(myActivityId) { activity -&gt;\n    // Execute actions when MyActivity is started\n}\n</code></pre>"},{"location":"kernel/components/subcomponents/intent_manager/","title":"Intent Manager","text":"<p>El subcomponente <code>Intent Manager</code> corresponde a la secci\u00f3n del kernel que se encarga de interceptar los eventos  relacionados con los intents de la aplicaci\u00f3n para realizar las acciones correspondientes. La finalidad de este es facilitar al cliente la gesti\u00f3n de los intents de la aplicaci\u00f3n. Se centra en gestionar la peticion de intents,  centralizando la gesti\u00f3n de los mismos y facilitando la peticion de intents externos del sistema, como puede ser la apertura de la camara para realizar una foto.</p>"},{"location":"kernel/components/subcomponents/intent_manager/#peticion-de-intents","title":"Petici\u00f3n de intents","text":"<p>El subcomponente expone una serie de m\u00e9todos que permiten realizar peticiones de intents de manera sencilla.</p>"},{"location":"kernel/components/subcomponents/kernel_configurator/","title":"Kernel Configurator","text":"<p>The <code>KernelConfigurator</code> is a subcomponent responsible for configuring the microkernel and its components in the application. All the configurations are done by this subcomponent. It prepares all the configurations preset in each component and also registers all the plugins, initializes them and sets the pertinent configurations. That is the first component initialized, and it allows to realize certain actions before and after the initialization of the microkernel.</p>"},{"location":"kernel/components/subcomponents/preferences_manager/","title":"Preferences Manager","text":"<p>El subcomponente <code>Preferences Manager</code> es responsable de la gesti\u00f3n de las preferencias de la aplicaci\u00f3n. Este subcomponente es responsable de la inicializaci\u00f3n, configuraci\u00f3n y lectura de las preferencias de la aplicaci\u00f3n. Busca centralizar la gesti\u00f3n de las preferencias de la aplicaci\u00f3n y proporcionar una interfaz unificada para acceder a las mismas.</p>"}]}