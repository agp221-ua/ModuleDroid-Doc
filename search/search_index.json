{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>aqui iria una explicacion de que es y que quiere hacer</p>"},{"location":"about/","title":"About","text":""},{"location":"configurator/","title":"Configurator","text":""},{"location":"navigator/","title":"Navigator","text":""},{"location":"kernel/kernel/","title":"ModuleDroid Kernel","text":""},{"location":"kernel/kernel/#introduction","title":"Introduction","text":"<p> La documentacion del kernel de ModuleDroid esta pensada para aquellos que desean desarrollar modulos o plugins para el framework o quieren saber mas sobre el funcionamiento del mismo. No es necesario conocer el funcionamiento interno del kernel para utilizar el framework.</p> <p>ModuleDroid esta basado en un sistema de modulos y plugins, de forma que cada modulo es independiente del resto, y puede ser a\u00f1adido o eliminado del sistema en cualquier momento. Para ello, el sistema esta compuesto por un nucleo (kernel) que se encarga de gestionar los modulos y plugins que se ejecutan en el sistema, asi como de gestionar los eventos que se producen en \u00e9l. </p> <p>Internamente, el kernel esta compuesto a su vez por un conjunto de componentes que se encargan de gestionar los diferentes aspectos del sistema, de forma que si un modulo necesita interactuar con un aspecto del sistema, lo hace a traves del kernel y este se encarga de gestionar la interaccion con el componente correspondiente.</p> <p></p> <pre><code>flowchart TB\n    subgraph k[KERNEL]\n        direction TB\n        f(Facade)\n        subgraph c[INTERNAL BUS]\n            c1(Internal Bus)\n        end\n        subgraph sc[SUBCOMPONENTS]\n            sc1(Current Context Manager)\n            sc2(Activity Lifecycle)\n            sc3(Kernel Configurator)\n        end\n    end\n\n    subgraph p[Plugins]\n        direction LR\n        pa(Plugin 1) \n        pb(Plugin 2)\n        pc(Plugin N)\n    end\n    p --&gt; f\n\n    f &lt;-.-&gt; sc\n    c &lt;-.-&gt; sc\n    sc ---&gt; System\n</code></pre>"},{"location":"kernel/kernel/#plugins","title":"Plugins","text":"<p>Los plugins son modulos que se ejecutan de forma independiente al kernel, de forma que pueden ser a\u00f1adidos o eliminados de la aplicacion en cualquier momento sin afectar al resto de modulos. </p> <p>Para ello, los plugins se comunican con el kernel a traves del componente Facade, de  forma que el plugin se absrae de la implementacion interna del kernel y solo se comunica con el nucleo a traves de una interfaz.</p>"},{"location":"kernel/kernel/#kernel","title":"Kernel","text":"<p>El kernel es el nucleo del framework, por lo que es el encargado de gestionar los modulos o plugins que se ejecutan en el sistema, asi como de gestionar los eventos que se producen en \u00e9l. Internamente, el kernel esta compuesto a su vez por un conjunto de componentes que se encargan de gestionar los diferentes aspectos del sistema, de forma que si un modulo necesita interactuar con un aspecto del sistema, lo hace a traves del kernel y este se encarga de gestionar la interaccion con el componente correspondiente.</p> <p> El kernel es un componente que se ejecuta en el hilo principal de la aplicacion, por lo que no se debe ejecutar codigo bloqueante en \u00e9l.</p> <p> Acceder a algun aspecto del sistema sorteando el kernel puede provocar comportamientos inesperados en el sistema, por lo que se recomienda no hacerlo. Si se necesita acceder a algun aspecto del sistema no implementado en el kernel, se recomienda notificar al equipo de desarrollo para que baraje la posibilidad de a\u00f1adirlo al kernel o otorgen alguna solucion alternativa.</p>"},{"location":"kernel/kernel/#componentes","title":"Componentes","text":"<p>Como se ha comentado anteriormente, el kernel esta compuesto por un conjunto de componentes que se encargan de gestionar y facilitar el acceso los diferentes aspectos del sistema. </p> <p>A continuaci\u00f3n detallamos los componentes que componen el kernel:</p> <p>Facade</p><p>Gestor de llamadas a los subcomponentes desde los plugins</p> <p>Internal Bus</p><p>Gestor de la comunicacion entre los subcomponentes del kernel</p> <p>Activity Lifecycle</p><p>Gestor de eventos suscritos a los ciclos de vida de las activities</p> <p>Bluetooth Manager</p><p>Gestor de eventos relacionados con el bluetooth</p> <p>Current Context Manager</p><p>Gestor de eventos y recursos relacionados con el contexto actual</p> <p>Device Info Manager</p><p>Gestor de eventos y recursos relacionados con la informacion del dispositivo</p> <p>Intent Manager</p><p>Gestor de eventos relacionados con los intents</p> <p>Kernel Configurator</p><p>Gestor de eventos relacionados con la configuracion del kernel</p> <p>Localization Manager</p><p>Gestor de eventos relacionados con la localization</p> <p>Network Manager</p><p>Gestor de eventos relacionados con la red</p> <p>Notification Manager</p><p>Gestor de eventos relacionados con las notificaciones</p> <p>Permission Manager</p><p>Gestor de eventos relacionados con los permisos</p> <p>Preferences Manager</p><p>Gestor de eventos relacionados con las preferencias</p> <p>Sensor Manager</p><p>Gestor de eventos relacionados con los sensores</p> <p>Speech Manager</p><p>Gestor de eventos relacionados con el reconocimiento de voz y lectura de texto</p> <p>Task Scheduler</p><p>Gestor de eventos relacionados con la planificacion de tareas</p> <p>Theme Manager</p><p>Gestor de eventos relacionados con los temas</p> <p>Thread Manager</p><p>Gestor de eventos relacionados con los hilos</p>"},{"location":"kernel/components/facade_kernel/","title":"Kernel Facade","text":"<p>El Kernel Facade es el componente que se encarga de gestionar las llamadas de los modulos al kernel, y de gestionar las respuestas del kernel a los modulos. Basicamente es un intermediario entre los modulos y el kernel, que se encarga de que la comunicacion entre ambos sea correcta y lo mas sencilla posible de cara a los modulos y el usuario final.</p>"},{"location":"kernel/components/facade_kernel/#funcionamiento","title":"Funcionamiento","text":"<p>El funcionamiento del Kernel Facade es muy sencillo. Basicamente se encarga de gestionar las llamadas de los modulos a los componentes del kernel y viceversa, de forma que los modulos no tengan que preocuparse de saber como se comunican con el kernel. Para ello, el Kernel Facade expone una serie de metodos que los modulos pueden utilizar para comunicarse con los componentes internos, ya que la principal funcion del Kernel Facade es la de abstraer a los modulos de la complejidad de la comunicacion con los componentes del kernel y  evitar la necesidad de saber y depender de como funciona internamente el framework.</p>"},{"location":"kernel/components/facade_kernel/#estructura","title":"Estructura","text":"<pre><code>    flowchart TB\n        subgraph p[\" \"]\n            direction LR\n            pa(Plugin 1) \n            pb(Plugin 2)\n            pc(Plugin N)\n        end\n\n        subgraph f[\" \"]\n            f1(Facade)\n            subgraph sf[\"  \"]\n                sf1(Subfacade 1)\n                sf2(Subfacade 2)\n                sf3(Subfacade N)\n            end\n        end\n        subgraph sc[\" \"]\n            direction TB\n            sc1(Subcomponent 1)\n            sc2(Subcomponent 2)\n            sc3(Subcomponent N)\n        end\n\n        p --&gt; f\n        f1 --&gt; sf1\n        f1 --&gt; sf2\n        f1 --&gt; sf3\n        sf1 --&gt; sc1\n        sf2 --&gt; sc2\n        sf3 --&gt; sc3\n</code></pre> <p>Info</p> <p>Se puede observar que el Kernel Facade esta compuesto por un conjunto de subfacade, los cuales se encargan de gestionar las llamadas a los componentes internos del kernel. Esta subdivision se debe a que el Kernel Facade es un componente muy complejo, por lo que se ha decidido dividirlo en subfacade para facilitar su comprension y mantenimiento.</p>"},{"location":"kernel/components/internal_bus/","title":"Kernel Internal Bus","text":""},{"location":"kernel/components/internal_bus/#introduction","title":"Introduction","text":"<p>Internal Bus es uno de los componentes principales que, a diferencia de los subcomponentes, no se centra ni en la obtencion de resultados ni el el trato de ellos, sino que se encarga de gestionar aquellos datos que son globales al framework y por lo tanto no pueden ser privatizados en un componente especifico. Esta funcionalidad puede ser util para ciertas acciones que necesitan datos que no pertenecen al dominio de cierto subcomponente en concreto pero sean necesarios para realizar dicha acci\u00f3n. Es por ello que, para evitar insertar dependencias innecesarias en los subcomponentes, se ha creado Internal Bus como bus interno de datos globales.</p> <p>Por ejemplo, el subcomponente encargado de ofrecer la Activity actual, no debe conocer el sistema de obtencion de la Activity actual ni deber\u00eda saber quien es el encargado de ello. Ahi entra en juego Internal Bus, ya que es el encargado de otorgar esos datos a los subcomponentes que lo necesiten, abstrayendolos de la complejidad de la obtencion de dichos datos.</p> <p>Nota</p> <p>Internal Bus no conoce los subcomponentes del kernel, tan solo se centra en la conexion de datos entre ellos.</p>"},{"location":"kernel/components/internal_bus/#estructura","title":"Estructura","text":"<pre><code>    flowchart TB\n        subgraph k[KERNEL]\n            direction TB\n            subgraph c[\" \"]\n                c1(Subcomponent 1)\n                c2(Subcomponent 2)\n                c3(Subcomponent N)\n            end\n            direction TB\n            ib(Internal Bus)\n        end\n        c --&gt; System\n        c1 &lt;-.-&gt; ib\n        c2 &lt;-.-&gt; ib\n        c3 &lt;-.-&gt; ib\n</code></pre> <p>Para maximizar la independencia de Internal Bus respecto a los subcomponentes, se hace uso de un enum, <code>Keys</code>, que contiene las claves de los datos que se pueden obtener de otros subcomponentes. De esta forma, los subcomponentes no necesitan conocer la estructura de Internal Bus, tan solo necesitan conocer la clave del dato que necesitan y Internal Bus se encarga de obtenerlo de forma activa. Para ello, Internal Bus espera que en algun momento de la configuracion del kernel, se suscriban a cada key los subcomponentes que puedan ofrecer dicho dato. </p>"},{"location":"kernel/components/internal_bus/#suscripcion-de-datos","title":"Suscripcion de datos","text":"<p>Ya mencionado anteriormente, Internal Bus no conoce los subcomponentes del kernel, por lo que emplea un sistema de suscripcion para que los subcomponentes puedan ofrecer sus datos a Internal Bus. Para ello, Internal Bus expone un metodo, <code>subscribe</code>, que recibe como parametro la clave del dato que se desea suscribir y un callback que se ejecutara cuando se solicite dicho dato.</p>"},{"location":"kernel/components/internal_bus/#obtencion-de-datos","title":"Obtencion de datos","text":"<p>Para obtener los datos, Internal Bus expone un metodo, <code>get</code>, que recibe como parametro la clave del dato que se desea obtener. Este metodo se encarga de buscar en el mapa de suscripciones si existe algun subcomponente que ofrezca dicho dato, y en caso de que exista, ejecuta el callback asociado a dicho dato, recupera el dato y lo devuelve. En caso de que no exista una suscripcion asociada a la clave, se lanza una excepcion.</p>"},{"location":"kernel/components/subcomponents/activity_lifecycle/","title":"Activity Lifecycle","text":"<p>El subcomponente <code>Activity Lifecycle</code> corresponde a la seccion del kernel que se encarga de interceptar los eventos del ciclo de vida de las actividades de la aplicacion para realizar las acciones correspondientes. La finalidad de este es la de permitir que los otros subcomponentes y plugins de la aplicacion puedan reaccionar a los eventos del ciclo de vida de las activities para realizar diversas acciones.</p> Ejemplo <p>Pongamos como ejemplo el caso de un plugin que se encarga de la navegacion entre pantallas de la aplicacion.  Este plugin necesita saber cuando se crea una nueva activity para poder pasar los datos pertinentes a la nueva pantalla. Para ello podr\u00eda suscribirse al evento <code>onCreate</code> del ciclo de vida de las activities y realizar las acciones correspondientes cuando este evento se produzca.</p> Info <p>Por el momento, el subcomponente <code>Activity Lifecycle</code> no es capaz de interceptar los eventos del ciclo de vida de fragmentos de manera oficial.</p>"},{"location":"kernel/components/subcomponents/activity_lifecycle/#suscripcion-a-eventos","title":"Suscripcion a eventos","text":"<p>Como ya se ha comentado, el subcomponente <code>Activity Lifecycle</code> hace uso de un sistema de suscripcion a los eventos del ciclo de vida de las activities. Para ello, <code>Activity Lifecycle</code> expone una serie de metodos que permiten suscribirse a los eventos del ciclo de vida de las activities.</p> <p>Para conseguir esto, el subcomponente <code>Activity Lifecycle</code> intercepta los eventos haciendo uso de una Application personalizada que se encarga de registrar un <code>ActivityLifecycleCallbacks</code> en el <code>Application.ActivityLifecycleCallbacks</code> de la aplicacion. De esta manera, cuando se produzca un evento del ciclo de vida de una activity, antes de que se ejecute el metodo correspondiente de la activity, se ejecutaran todas las suscripciones a dicho evento que cumplan las restricciones  pertinentes (explicadas mas abajo).</p> Alerta <p>Este componente hace uso de una <code>Application</code> personalizada. Si por algun motivo se necesita hacer uso de una Application propia, se debera tener en cuenta que el subcomponente <code>Activity Lifecycle</code> puede no funcionar correctamente. Para reducir las posibles incompatibilidades, deber\u00e1 extender de la <code>Application</code> del subcomponente <code>Activity Lifecycle</code> y llamar al metodo <code>super</code> en el metodo <code>onCreate</code>. </p>"},{"location":"kernel/components/subcomponents/activity_lifecycle/#eventos-disponibles","title":"Eventos disponibles","text":"<p><code>Activity Lifecycle</code> expone una serie de eventos que se corresponden con los eventos del ciclo de vida de las activities de Android. Estos eventos son los siguientes:</p>"},{"location":"kernel/components/subcomponents/activity_lifecycle/#oncreate","title":"<code>onCreate</code>","text":""},{"location":"kernel/components/subcomponents/activity_lifecycle/#onstart","title":"<code>onStart</code>","text":""},{"location":"kernel/components/subcomponents/activity_lifecycle/#onresume","title":"<code>onResume</code>","text":""},{"location":"kernel/components/subcomponents/activity_lifecycle/#onpause","title":"<code>onPause</code>","text":""},{"location":"kernel/components/subcomponents/activity_lifecycle/#onstop","title":"<code>onStop</code>","text":""},{"location":"kernel/components/subcomponents/activity_lifecycle/#ondestroy","title":"<code>onDestroy</code>","text":""},{"location":"kernel/components/subcomponents/activity_lifecycle/#onrestart","title":"<code>onRestart</code>","text":""},{"location":"kernel/components/subcomponents/activity_lifecycle/#onactivitysaveinstancestate","title":"<code>onActivitySaveInstanceState</code>","text":""},{"location":"kernel/components/subcomponents/bluetooth_manager/","title":"Bluetooth Manager","text":"<p>El subcomponente <code>Bluetooth Manager</code> es responsable de la gesti\u00f3n de la conectividad Bluetooth, es decir, se encarga de gestionar los diferentes eventos relacionados con la conectividad Bluetooth, como la detecci\u00f3n de dispositivos, la conexi\u00f3n y desconexi\u00f3n de dispositivos, la lectura y escritura de datos, etc.</p>"},{"location":"kernel/components/subcomponents/bluetooth_manager/#gestion-de-eventos","title":"Gestion de eventos","text":"<p>El subcomponente gestiona los siguientes eventos:</p>"},{"location":"kernel/components/subcomponents/bluetooth_manager/#deteccion-de-dispositivos","title":"Detecci\u00f3n de dispositivos","text":""},{"location":"kernel/components/subcomponents/bluetooth_manager/#conexion-de-dispositivos","title":"Conexi\u00f3n de dispositivos","text":""},{"location":"kernel/components/subcomponents/bluetooth_manager/#desconexion-de-dispositivos","title":"Desconexi\u00f3n de dispositivos","text":""},{"location":"kernel/components/subcomponents/bluetooth_manager/#lectura-y-escritura-de-datos","title":"Lectura y escritura de datos","text":"<p>El subcomponente tambi\u00e9n es responsable de la lectura y escritura de datos a trav\u00e9s de la conexi\u00f3n Bluetooth. Se facilita una interfaz para la lectura y escritura de datos, tanto como String, como en tipos primitivos o binarios.</p>"},{"location":"kernel/components/subcomponents/bluetooth_manager/#lectura-de-datos","title":"Lectura de datos","text":""},{"location":"kernel/components/subcomponents/bluetooth_manager/#escritura-de-datos","title":"Escritura de datos","text":""},{"location":"kernel/components/subcomponents/current_context_manager/","title":"Current Context Manager","text":"<p>El subcomponente <code>Current Context Manager</code> corresponde a la seccion del kernel que se encarga de gestionar los recursos necesarios que dependen del contexto actual de la aplicacion. La finalidad de este subcomponente es la de permitir que los otros subcomponentes y plugins de la aplicacion puedan acceder a los recursos que dependen del contexto actual de la aplicacion sin depender directamente de la actividad o fragmento actual.</p>"},{"location":"kernel/components/subcomponents/current_context_manager/#obtencion-del-contexto-actual","title":"Obtencion del contexto actual","text":"<p>Para obtener el contexto actual de la aplicacion, el subcomponente <code>Current Context Manager</code> hace uso de un metodo con visibilidad restringida que permite obtener el contexto actual de la aplicacion personalizada ya mencionada en <code>Activity Lifecycle</code>. Este sistema ofrece al subcomponente el contexto actual de manera segura, para facilitar el acceso a los recursos que dependen de este.</p> Tip <p>Igualmente, se ofrece la posibilidad de desactivar la obtencion del contexto de forma automatica y sustituirlo por un sistema manual, el cual permite establecer el contexto actual (a nivel de microkernel, no de aplicacion) al cliente, para casos mas especificos en los que se requiera un control mas preciso del contexto. Se detalla m\u00e1s a fondo posteriormente en esta pagina.</p>"},{"location":"kernel/components/subcomponents/current_context_manager/#recursos","title":"Recursos","text":"<p>El subcomponente <code>Current Context Manager</code> ofrece una forma sencilla y directa de conseguir recursos mediante el uso de identificadores. Estos identificadores son los que se definen en los archivos XML de recursos de la aplicacion. Facilita tanto la obtencion de colores (no dependientes del tema), como de cadenas de texto, dimensiones, estilos, etc.</p>"},{"location":"kernel/components/subcomponents/device_info_manager/","title":"Device Info Manager","text":"<p>El subcomponente <code>DeviceInfoManager</code> es responsable de la gesti\u00f3n de la informaci\u00f3n del dispositivo. Proporciona informaci\u00f3n sobre el dispositivo, como el nombre del dispositivo, el n\u00famero de serie, el modelo, la versi\u00f3n del firmware, etc.</p>"},{"location":"kernel/components/subcomponents/intent_manager/","title":"Intent Manager","text":"<p>El subcomponente <code>Intent Manager</code> corresponde a la secci\u00f3n del kernel que se encarga de interceptar los eventos  relacionados con los intents de la aplicaci\u00f3n para realizar las acciones correspondientes. La finalidad de este es facilitar al cliente la gesti\u00f3n de los intents de la aplicaci\u00f3n. Se centra en gestionar la peticion de intents,  centralizando la gesti\u00f3n de los mismos y facilitando la peticion de intents externos del sistema, como puede ser la apertura de la camara para realizar una foto.</p>"},{"location":"kernel/components/subcomponents/intent_manager/#peticion-de-intents","title":"Petici\u00f3n de intents","text":"<p>El subcomponente expone una serie de m\u00e9todos que permiten realizar peticiones de intents de manera sencilla.</p>"},{"location":"kernel/components/subcomponents/kernel_configurator/","title":"Kernel Configurator","text":"<p>The <code>KernelConfigurator</code> is a subcomponent responsible for configuring the microkernel and its components in the application. All the configurations are done by this subcomponent. It prepares all the configurations preset in each component and also registers all the plugins, initializes them and sets the pertinent configurations. That is the first component initialized, and it allows to realize certain actions before and after the initialization of the microkernel.</p>"}]}