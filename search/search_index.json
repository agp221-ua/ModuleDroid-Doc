{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>aqui iria una explicacion de que es y que quiere hacer</p>"},{"location":"about/","title":"About","text":""},{"location":"configurator/","title":"Configurator","text":""},{"location":"navigator/","title":"Navigator","text":""},{"location":"kernel/kernel/","title":"ModuleDroid Kernel","text":""},{"location":"kernel/kernel/#introduction","title":"Introduction","text":"Info <p>The ModuleDroid kernel documentation is intended for those who wish to develop modules or plugins for the framework or want to learn more about its inner workings. It is not necessary to understand the internal operation of the kernel to use the framework.</p> <p>ModuleDroid is based on a system of modules or plugins, where each one is independent of the rest and can be added or removed from the system at any time. The system consists of a core (kernel) that manages the modules and plugins running in the system, as well as the events that occur within it.</p> <p>Internally, the kernel is composed of a set of components responsible for managing different aspects of the system. If a module needs to interact with any system functionality, it does so through the kernel, which then handles the interaction with the corresponding component.</p> <p></p> <pre><code>flowchart TB\n    subgraph k[KERNEL]\n        direction TB\n        f(Facade)\n        subgraph c[INTERNAL BUS]\n            c1(Internal Bus)\n        end\n        subgraph sc[SUBCOMPONENTS]\n            sc1(Activity Lifecycle)\n            sc2(Intent manager)\n            sc3(Kernel Configurator)\n            sc4(Preferences Manager)\n        end\n    end\n\n    subgraph p[Plugins]\n        direction LR\n        pa(Plugin 1) \n        pb(Plugin 2)\n        pc(Plugin N)\n    end\n    p --&gt; f\n\n    f &lt;-.-&gt; sc\n    c &lt;-.-&gt; sc\n    sc ---&gt; System\n</code></pre>"},{"location":"kernel/kernel/#plugins","title":"Plugins","text":"<p>Plugins are modules that operate independently of the kernel, meaning they can be added or removed from the application at any time without affecting other modules.</p> Note <p>It is possible to create plugins that rely on other plugins as dependencies; however, this practice should be minimized to maintain the independence of each plugin as much as possible.</p> <p>Plugins communicate with the kernel via the Facade component, allowing the plugin to remain abstracted from the kernel's internal implementation and only interact with the core through a defined interface.</p>"},{"location":"kernel/kernel/#kernel","title":"Kernel","text":"<p>The kernel is the core of the framework, responsible for managing the modules or plugins running in the system and handling the events that occur within it. Internally, the kernel consists of a set of components that manage various aspects of the system. If a module needs to interact with any system functionality, it communicates with the kernel, which then handles the interaction with the appropriate component.</p> Warning <p>The kernel utilizes a customized <code>Application</code> class. If, for any reason, there is a need to implement a custom Application, it is important to consider that the kernel may not function correctly. To minimize potential incompatibilities, it is recommended to extend from <code>ModuleDroidApplication</code> in the <code>Kernel Configurator</code> subcomponent and to call the <code>super</code> method within the <code>onCreate</code> method.</p> Warning <p>The kernel runs on the main thread of the application, so blocking code should not be executed within it.</p> Warning <p>Accessing any aspect of the system by bypassing the kernel may result in unexpected behavior. It is recommended to avoid this practice. If access to a system functionality not implemented in the kernel is required, please notify the development team to consider adding it to the kernel or provide an alternative solution.</p>"},{"location":"kernel/kernel/#components","title":"Components","text":"<p>As previously mentioned, the kernel is composed of a set of components responsible for managing and facilitating access to different aspects of the system.</p> <p>Below are the components that make up the kernel:</p> <p>Facade</p><p>Manages calls to subcomponents from plugins</p> <p>Internal Bus</p><p>Manages communication between kernel subcomponents</p> <p>Activity Lifecycle</p><p>Manages events subscribed to the activity lifecycle</p> <p>Intent Manager</p><p>Manages events related to intents</p> <p>Kernel Configurator</p><p>Manages events related to kernel configuration</p> <p>Preferences Manager</p><p>Manages events related to preferences</p>"},{"location":"kernel/components/facade_kernel/","title":"Facade","text":"<p>The Kernel Facade is the component responsible for managing the communication between modules and the kernel, as well as handling the kernel's responses to the modules. Essentially, it acts as an intermediary between the modules and the kernel, ensuring that communication is smooth and as simple as possible for both the modules and the end user.</p>"},{"location":"kernel/components/facade_kernel/#functionality","title":"Functionality","text":"<p>The operation of the Kernel Facade is straightforward. It handles the communication between modules and kernel components, and vice versa, so that the modules do not need to worry about how they interact with the kernel. To achieve this, the Kernel Facade exposes a set of methods that the modules can use to communicate with the internal components. The primary function of the Kernel Facade is to abstract the complexity of kernel communication from the modules, allowing them to avoid needing to understand or depend on the internal workings of the framework.</p>"},{"location":"kernel/components/facade_kernel/#structure","title":"Structure","text":"<p>Info</p> <p>The Kernel Facade is composed of a set of subfacades, each responsible for managing communication with specific internal kernel components. This subdivision exists because the Kernel Facade is a highly complex component, and splitting it into subfacades helps improve its comprehensibility and maintainability.</p> <pre><code>    flowchart TB\n        subgraph p[\" \"]\n            direction LR\n            pa(Plugin 1) \n            pb(Plugin 2)\n            pc(Plugin N)\n        end\n\n        subgraph f[\" \"]\n            f1(Facade)\n            subgraph sf[\"  \"]\n                sf1(Subfacade 1)\n                sf2(Subfacade 2)\n                sf3(Subfacade N)\n            end\n        end\n        subgraph sc[\" \"]\n            direction TB\n            sc1(Subcomponent 1)\n            sc2(Subcomponent 2)\n            sc3(Subcomponent N)\n        end\n\n        p --&gt; f\n        f1 --&gt; sf1\n        f1 --&gt; sf2\n        f1 --&gt; sf3\n        sf1 --&gt; sc1\n        sf2 --&gt; sc2\n        sf3 --&gt; sc3\n</code></pre>"},{"location":"kernel/components/internal_bus/","title":"Internal Bus","text":""},{"location":"kernel/components/internal_bus/#introduction","title":"Introduction","text":"<p>The <code>Internal Bus</code> is one of the core components that, unlike subcomponents, does not focus on obtaining or processing results. Instead, it is responsible for managing data that is global to the framework and, therefore, cannot be privatized within a specific component. This functionality is useful for actions that require data not belonging to a particular subcomponent but are necessary to perform a given task. To avoid inserting unnecessary dependencies into subcomponents, the <code>Internal Bus</code> was created as an internal bus for global data.</p> <p>For example, the subcomponent responsible for providing the current <code>Activity</code> should not know the system used to obtain it, nor should it be aware of who is responsible for it. This is where the <code>Internal Bus</code> comes into play, as it provides these data to the subcomponents that need them, abstracting them from the complexity of obtaining the data.</p> Note <p><code>Internal Bus</code> does not know the kernel subcomponents; it only focuses on connecting data between them.</p>"},{"location":"kernel/components/internal_bus/#structure","title":"Structure","text":"<pre><code>    flowchart TB\n        subgraph k[KERNEL]\n            direction TB\n            subgraph c[\" \"]\n                c1(Subcomponent 1)\n                c2(Subcomponent 2)\n                c3(Subcomponent N)\n            end\n            direction TB\n            ib(Internal Bus)\n        end\n        c --&gt; System\n        c1 &lt;-.-&gt; ib\n        c2 &lt;-.-&gt; ib\n        c3 &lt;-.-&gt; ib\n</code></pre> <p>To maximize the independence of the <code>Internal Bus</code> from subcomponents, an enum called <code>Keys</code> is used. This enum contains the keys for the data that can be obtained from other subcomponents. This way, subcomponents do not need to know the structure of the Internal Bus, they only need to know the key for the data they require, and the <code>Internal Bus</code> takes care of actively retrieving it. For this, <code>Internal Bus</code> expects subcomponents that can provide the data to subscribe to each <code>key</code> during the kernel configuration process.</p>"},{"location":"kernel/components/internal_bus/#data-subscription","title":"Data Subscription","text":"<p>As previously mentioned, the Internal Bus does not know the kernel subcomponents, so it uses a subscription system to allow subcomponents to offer their data to the <code>Internal Bus</code>. For this, the <code>Internal Bus</code> exposes a method, <code>subscribe</code>, which takes as parameters the key of the data to be subscribed and a callback that will be executed when the data is requested.</p>"},{"location":"kernel/components/internal_bus/#data-retrieval","title":"Data Retrieval","text":"<p>To retrieve data, the Internal Bus exposes a method, <code>get</code>, which takes as a parameter the key of the data to be obtained. This method searches the subscription map to check if any subcomponent provides the requested data. If it exists, the associated callback is executed, the data is retrieved, and returned. If no subscription is associated with the key, an exception is thrown.</p>"},{"location":"kernel/components/subcomponents/activity_lifecycle/","title":"Activity Lifecycle","text":"<p>The <code>Activity Lifecycle</code> subcomponent is a part of the kernel responsible for intercepting the lifecycle events of the application's activities to execute corresponding actions. Its purpose is to allow other subcomponents and application plugins to react to these activity lifecycle events to perform various actions.</p> Example <p>For instance, consider a plugin that manages navigation between screens in the application. This plugin needs to know when a new activity is created to pass relevant data to the new screen. To achieve this, it could subscribe to the <code>onCreate</code> event in the activity lifecycle and execute the necessary actions when this event occurs.</p> Info <p>Currently, the <code>Activity Lifecycle</code> subcomponent does not officially support intercepting fragment lifecycle events.</p>"},{"location":"kernel/components/subcomponents/activity_lifecycle/#retrieving-activities","title":"Retrieving Activities","text":"Warning <p>The reference to these Activities can change at any time, so it is recommended not to store the reference but to call the method when needed. Another option is to create a computed property where the getter calls the desired method.</p> <p>To retrieve Activities, the Facade provides different options depending on the situation:</p> Method Description Current Activity Returns the activity that is currently resumed. Resuming Activity Returns the activity that is currently resuming. Starting Activity Returns the activity that is currently starting. Creating Activity Returns the activity that is currently being created. Preferred Activity Returns the activity in the order <code>resuming</code> &gt; <code>starting</code> &gt; <code>creating</code> &gt; <code>current</code>. This is offered as a simplified solution to access the activity during uncertain times when the state is unknown. <p>Alternatively, there are two methods to retrieve the desired activity: one that returns a nullable value (Activity?) and another that returns a non-nullable value (Activity), which will throw an <code>IllegalStateException</code> if the desired activity is not found.</p> Example <p>For example, let's assume we want to obtain the current activity of the application from a code where direct access to the activity is not available.</p> <pre><code>// Optional way\nval currentActivity = Facade.getCurrentActivity() ?: // Handle case where no activity is found\n\n// Exception way\ntry {\n    val currentActivity = Facade.getCurrentActivityOrFail()\n} catch (e: IllegalStateException) {\n    // Handle case where no activity is found\n}\n\n// Property way\nval currentActivity: Activity?\n    get() {\n        return Facade.getCurrentActivity()\n    }\n//...\nthis.currentActivity // Access the current activity\n</code></pre>"},{"location":"kernel/components/subcomponents/activity_lifecycle/#event-subscription","title":"Event Subscription","text":"<p>As mentioned earlier, the <code>Activity Lifecycle</code> subcomponent uses a subscription system for activity lifecycle events. The <code>Activity Lifecycle</code> provides a set of methods that allow subscribing to these events.</p> <p>To achieve this, the <code>Activity Lifecycle</code> subcomponent intercepts lifecycle events. When an activity lifecycle event occurs, before the corresponding activity method is executed, all subscriptions to that event that meet the relevant conditions are executed.</p> <p>The available events for subscription are: <code>onPreCreate</code>, <code>onCreate</code>, <code>onPostCreate</code>, <code>onPreStart</code>, <code>onStart</code>, <code>onPostStart</code>, <code>onPreResume</code>, <code>onResume</code>, <code>onPostResume</code>, <code>onPrePause</code>, <code>onPause</code>, <code>onPostPause</code>, <code>onPreStop</code>, <code>onStop</code>, <code>onPostStop</code>, <code>onPreDestroy</code>, <code>onDestroy</code>, <code>onPostDestroy</code>, <code>onRestart</code>, <code>onSaveInstanceState</code>.</p> <p>Additionally, all of these events offer different subscription method versions, adapting to the specific case as needed based on certain conditions:</p> Method call parameters Description <code>subscription</code> This call simply adds the subscription, which will be executed when the event is captured. <code>id</code><code>subscription</code> This call only executes the subscription when the id of the current activity matches <code>id</code>. <code>activityClass</code><code>subscription</code> This call only executes the subscription when the class of the current activity matches <code>activityClass</code>. <code>id</code><code>activityClass</code><code>subscription</code> This call only executes the subscription when both the id and class of the current activity match <code>id</code> and <code>activityClass</code>, respectively. Example <p>Suppose we want to subscribe to the <code>onCreate</code> event of a specific activity. We could use the following call:</p> <pre><code>Facade.addOnCreateSubscription { activity, bundle -&gt;\n    // Execute actions when MyActivity is created\n}\n</code></pre> <p>Now, imagine we want to subscribe to the <code>onStart</code> event of the activity with id <code>myActivityId</code>:</p> <pre><code>Facade.addOnStartSubscription(myActivityId) { activity -&gt;\n    // Execute actions when MyActivity is started\n}\n</code></pre>"},{"location":"kernel/components/subcomponents/intent_manager/","title":"Intent Manager","text":"<p>The <code>Intent Manager</code> subcomponent is responsible for the part of the kernel that intercepts events related to the  application's intents to execute the corresponding actions. Its main goal is to simplify intent management for the  client by centralizing the handling of application intents.</p> Note <p>Currently, <code>Intent Manager</code> only supports <code>Intents</code> for launching Activities within the same application.</p>"},{"location":"kernel/components/subcomponents/intent_manager/#launching-activities","title":"Launching Activities","text":"<p>Two primary methods are provided for launching activities within the application:</p> Method Description startActivity Launches an activity within the application. It requires the destination activity's class as a mandatory parameter. Optionally, you can assign an ID to the destination activity and execute a pre-launch action through a lambda function, which provides parameters such as the intent used or the assigned ID (e.g., for cases where an ID is not specified). Additionally, the parent activity instance can be passed if you want to explicitly indicate the context from which it is created. startActivityForResult Launches an activity within the application and awaits a result. It requires the destination activity's class as a mandatory parameter. Optionally, you can assign an ID to the destination activity and execute a pre-launch action via a lambda function, which provides parameters such as the intent, the assigned ID (e.g., for cases where an ID is not specified), or a requestCode (if not provided, a generic one will be created). The parent activity can also be explicitly specified if needed. Example <p>For instance, let\u2019s say we want to launch an activity of class <code>OtherActivity</code>. <pre><code>Facade.startActivity(OtherActivity::class.java)\n</code></pre> Alternatively, if we want to launch the activity with a specific ID, we can do so as follows: <pre><code>Facade.startActivity(OtherActivity::class.java, \"id\")\n</code></pre> Furthermore, if we want to perform a pre-launch action and specify the source activity, we can do it like this: <pre><code>// Assuming we are within an activity\nFacade.startActivity(this, OtherActivity::class.java) { intent, id, internalId -&gt;\n    intent.putExtra(\"key\", \"example\")\n}\n</code></pre></p>"},{"location":"kernel/components/subcomponents/intent_manager/#activity-identifiers","title":"Activity Identifiers","text":"<p>To facilitate the identification of activities, <code>Intent Manager</code> assigns a unique identifier to each activity initiated  through its defined methods. This may result in activities without an identifier, so several methods are available to  provide an identifier to an activity if it lacks one, or to retrieve the identifier if it already has one:</p> Method Description getId Retrieves the identifier of the activity passed as a parameter. provideId Assigns an identifier to the activity passed as a parameter if it lacks one, and returns it. Note that if the activity already has an identifier, it will be overwritten. getIdOrProvideOne Retrieves the identifier of the activity passed as a parameter if it already has one, or assigns one if it lacks one, returning it in either case. Example <p>For instance, let\u2019s say we want to obtain the identifier of an activity: <pre><code>val activity: Activity = ...\nval id = Facade.getId(activity)\n</code></pre> Alternatively, if we want to assign an identifier to an activity that does not yet have one: <pre><code>val id = Facade.provideId(activity)\n</code></pre> On the other hand, if we want to retrieve the identifier of an activity if it already has one, or assign one if it  does not: <pre><code>val id = Facade.getIdOrProvideOne(OtherActivity::class.java)\n</code></pre></p> Tip <p>Among these methods, <code>getIdOrProvideOne</code> is the most recommended as it avoids constant checks and reduces the risk  of errors related to activity identification.</p>"},{"location":"kernel/components/subcomponents/intent_manager/#internal-identifiers","title":"Internal Identifiers","text":"<p>With the above method, potential issues arise, such as assigning duplicate identifiers to different activities. To avoid this, a unique internal identifier is maintained, allowing users to have activities with the same identifier while  internally assigning a unique identifier to each. This internal identifier can be retrieved through the <code>getInternalId</code>  method and cannot be assigned manually, as it is automatically assigned whenever an identifier is either manually or  automatically assigned.</p> Example <p>For instance, let\u2019s say we want to retrieve the internal identifier of an activity: <pre><code>val activity: Activity = ...\nval internalId = Facade.getInternalId(activity)\n</code></pre></p> Warning <p>Each time an activity\u2019s identifier is overwritten, the internal identifier will also be updated.</p>"},{"location":"kernel/components/subcomponents/kernel_configurator/","title":"Kernel Configurator","text":"<p>The <code>KernelConfigurator</code> is the subcomponent responsible for configuring the microkernel and its components within the  application. All configuration tasks are handled by this subcomponent, which prepares the configuration presets for each component, registers all plugins, initializes them, and applies the appropriate settings. As the first component to be  initialized, it enables certain actions to be performed before and after the initialization of the microkernel.</p>"},{"location":"kernel/components/subcomponents/kernel_configurator/#custom-application","title":"Custom <code>Application</code>","text":"<p>The <code>KernelConfigurator</code> requires access to the <code>Application</code> instance to configure the microkernel and its components.  This is why it utilizes a class that extends from <code>Application</code>, which has access to methods like <code>onCreate</code>, allowing  actions to be taken during the application\u2019s creation. These actions include initializing the various microkernel  subcomponents and registering plugins.</p> <p>For this reason, it is crucial that the <code>Application</code> instance is either an instance of or extends from  <code>ModuleDroidApplication</code>. To achieve this, simply add or replace the <code>Application</code> class in the <code>AndroidManifest.xml</code>  file with <code>ModuleDroidApplication</code>.</p> <pre><code>&lt;application \n        android:name=\"software.galaniberico.moduledroid.subcomponents.kernelconfigurator.ModuleDroidApplication\"\n        ...\n        &gt; \n        &lt;!-- ... --&gt;\n&lt;/application&gt;\n</code></pre> <p>By doing so, the <code>Application</code> instance will be of type <code>ModuleDroidApplication</code>, and the <code>KernelConfigurator</code> will  automatically have access to it.</p>"},{"location":"kernel/components/subcomponents/kernel_configurator/#plugin-registration","title":"Plugin Registration","text":"<p>As mentioned earlier, the <code>KernelConfigurator</code> is responsible for registering plugins within the microkernel. To simplify this process for developers and prevent them from having to manually register or configure plugins in their code, an  auto-registration system has been implemented. This system allows plugins to be automatically registered and configured  simply by adding the dependency to the application\u2019s <code>AndroidManifest.xml</code> using metadata:</p> <p>The plugin developer only needs to specify, in the plugin's documentation, the configurator class to be added to the list of plugins.</p> <pre><code>&lt;application \n        android:name=\"software.galaniberico.moduledroid.subcomponents.kernelconfigurator.ModuleDroidApplication\"\n        ...\n        &gt; \n        &lt;!-- ... --&gt;\n        &lt;meta-data\n            android:name=\"moduledroid_plugins\"\n            android:value=\"software.galaniberico.myplugin.MyPluginConfigurator\" \n            /&gt;\n&lt;/application&gt;\n</code></pre> Tip <p>Plugins can be listed using commas (<code>,</code>) and the list can contain line breaks and whitespace for improved readability. For instance: <pre><code>&lt;meta-data\n    android:name=\"moduledroid_plugins\"\n    android:value=\"software.galaniberico.myplugin.MyPlugin1Configurator,\n                   software.galaniberico.myplugin2.MyPlugin2Configurator,\n                   software.galaniberico.myplugin3.MyPlugin3Configurator\"  \n/&gt;\n</code></pre></p> Info <p>The provided class must extend the <code>PluginConfigurator</code> interface and have a parameterless constructor.</p>"},{"location":"kernel/components/subcomponents/preferences_manager/","title":"Preferences Manager","text":"<p>The <code>Preferences Manager</code> subcomponent is responsible for managing the application's preferences. It handles the initialization, configuration, and retrieval of the application's preferences. Its aim is to centralize the management of preferences and provide a unified interface for accessing them without unnecessary code repetition.</p>"},{"location":"kernel/components/subcomponents/preferences_manager/#retrieving-and-setting-preferences","title":"Retrieving and Setting Preferences","text":"<p>To retrieve or set the application's preferences, the following methods are available:</p> Method Description get Retrieves the value of a preference. It takes as parameters the preference key and the default value if the preference does not exist. Supports the types <code>String</code>, <code>Int</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>, <code>Long</code>, and <code>Set&lt;String&gt;</code>. set Sets the value of a preference. It takes as parameters the preference key and the value to be set. Supports the types <code>String</code>, <code>Int</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>, <code>Long</code>, and <code>Set&lt;String&gt;</code>. clear Clears all stored preferences. This is designed for testing and isolated cases. Example <p>To set a preference with the key \"my-key\" and the value \"my value\":</p> <pre><code>Facade.set(\"my-key\", \"my value\")\n</code></pre> <p>To retrieve the value of the preference:</p> <pre><code>val value = Facade.get(\"my-key\", \"default value\")\n// If it exists, it will be \"my value\", otherwise it will be \"default value\"\n</code></pre>"},{"location":"kernel/components/subcomponents/preferences_manager/#subscription-to-changes","title":"Subscription to Changes","text":"<p>The <code>Preferences Manager</code> subcomponent allows subscription to changes in the application's preferences, so that whenever a preference changes, the specified callbacks are executed. The following methods are available for this purpose:</p> Method Description addSubscription Adds a subscription to a preference. Takes the callback to be executed as a parameter in case any preference changes. removeSubscription Removes a subscription to a preference. Takes the callback to be removed as a parameter. Example <p>To add a subscription to the preference \"my-key\": <pre><code>Facade.addSubscription { _, key -&gt;\n    if (key == \"my-key\") {\n        //...\n    }\n}\n</code></pre></p> <p>To remove the subscription:</p> <pre><code>Facade.removeSubscription() {\n    if (key == \"my-key\") {\n        //...\n    }\n}\n</code></pre>"}]}